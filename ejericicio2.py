# -*- coding: utf-8 -*-
"""Ejericicio2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y0_50DURqpfu-wBDSXpMC6-1iqvUgZ-F
"""

#   Codigo que implementa el esquema numerico
#   de interpolacion para determinar la raiz de
#   una ecuacion
#
#           Autor:
#   Angel Gilberto Carbajal Lopez
#   carbajalsecundaria@gmail.com
#   Version 1.0 : 11/02/2025
#
import numpy as np
import matplotlib.pyplot as plt

# Función original
def f(x):
    return np.sin(x)-x/2 # Aqui se pone la ecuacion

# Interpolación de Lagrange
def lagrange_interpolation(x, x_puntos, y_puntos): # x es el punto donde se evalua el polinomio
    P_Interpolacion = len(x_points) # Se define el número de puntos de interpolación
    Resultado = 0 # Inicializar el resultado
    for Iteracion_i in range(P_Interpolacion): # Sumar los términos de la interpolación
        termino_Lag = y_puntos[Iteracion_i] # Inicializar el término de Lagrange
        for Iteracion_j in range(P_Interpolacion): # Calcular el término de Lagrange
            if Iteracion_i != Iteracion_j: # Si i es diferente de j entonces se calcula el término de Lagrange si no se omite
                termino_Lag *= (x - x_puntos[Iteracion_j]) / (x_puntos[Iteracion_i] - x_puntos[Iteracion_j]) # Calcular el término de Lagrange
        Resultado += termino_Lag # Sumar el término de Lagrange al resultado
    return Resultado

# Método de Bisección
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")

    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2  # Retorna la mejor estimación de la raíz

# Selección de tres puntos de interpolación
x0 = 0.0
x1 = 1.0
x2 = 2.0
x_points = np.array([x0, x1, x2]) # Valores de x para la funcion f(x)
y_points = f(x_points) # Resultados de la función en los puntos de interpolación

# Construcción del polinomio interpolante
# mediante interpolacion de Lagrange
x_vals = np.linspace(x0, x2, 100) # Muestra de puntos para graficar
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals] # Se evalua el polinomio interpolante en los puntos de muestra

# Encontrar raíz del polinomio interpolante usando bisección
# en el intervalo inducido por los puntos donde se hace la interpolacion
root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), x0, x2) # Se busca la raíz en el intervalo de interpolación

# Calcular errores
errores_absolutos = np.abs(y_interp - f(x_vals))
errores_relativos = errores_absolutos / np.where(np.abs(f(x_vals))==0, 1, np.abs(f(x_vals))) # Evitar división por cero
errores_cuadraticos = errores_absolutos**2
# Encabezado de la tabla
print(f"{'Iteración':<10}|{'x':<12}|{'Error absoluto':<18}|{'Error relativo':<18}|{'Error cuadrático'}")
print("-" * 80)

# Iterar sobre los valores calculados
for i, (x_val, error_abs, error_rel, error_cuad) in enumerate(zip(x_vals, errores_absolutos, errores_relativos, errores_cuadraticos)): # Imprimir los valores calculados
    print(f"{i+1:<10}|{x_val:<12.6f}|{error_abs:<18.6e}|{error_rel:<18.6e}|{error_cuad:.6e}")
# La función zip() se usa para combinar múltiples iterables (listas, tuplas, etc.) en pares o grupos de elementos.
# Se detiene cuando el iterable más corto se queda sin elementos.
# La función enumerate() agrega un contador a un iterable y lo devuelve en forma de objeto enumerado.

# Gráfica de errores
fig, ax = plt.subplots(1, 2, figsize=(14, 5))
ax[0].plot(x_vals, errores_absolutos, label="Error Absoluto", color='purple')
ax[0].plot(x_vals, errores_relativos, label="Error Relativo", color='orange')
ax[0].plot(x_vals, errores_cuadraticos, label="Error Cuadrático", color='brown')
ax[0].set_xlabel("x")
ax[0].set_ylabel("Errores")
ax[0].legend()
ax[0].grid(True)

# Gráfica
ax[1].plot(x_vals, f(x_vals), label="f(x) = sin(x) − x/2", linestyle='dashed', color='blue')
ax[1].plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
ax[1].axhline(0, color='black', linewidth=0.5, linestyle='--') # Eje x en y=0
ax[1].axvline(root, color='green', linestyle='dotted', label=f"Raíz aproximada: {root:.4f}") # Raíz aproximada encontrada
ax[1].scatter(x_points, y_points, color='black', label="Puntos de interpolación") # Puntos de interpolación
ax[1].set_xlabel("x")
ax[1].set_ylabel("f(x)")
ax[1].set_title("Interpolación y búsqueda de raíces")
ax[1].legend()
ax[1].grid(True)
plt.savefig("interpolacion_raices.png")  # Guarda la imagen
plt.show()

# Imprimir la raíz encontrada
print(f"La raíz aproximada usando interpolación es: {root:.4f}")